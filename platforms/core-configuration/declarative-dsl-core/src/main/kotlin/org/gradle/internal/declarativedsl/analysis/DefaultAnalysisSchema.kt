@file:Suppress("EqualsOrHashCode")

package org.gradle.internal.declarativedsl.analysis

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import org.gradle.declarative.dsl.schema.AnalysisSchema
import org.gradle.declarative.dsl.schema.ConfigureAccessor
import org.gradle.declarative.dsl.schema.ContainerElementFactory
import org.gradle.declarative.dsl.schema.DataBuilderFunction
import org.gradle.declarative.dsl.schema.DataClass
import org.gradle.declarative.dsl.schema.DataConstructor
import org.gradle.declarative.dsl.schema.DataMemberFunction
import org.gradle.declarative.dsl.schema.DataParameter
import org.gradle.declarative.dsl.schema.DataProperty
import org.gradle.declarative.dsl.schema.DataProperty.PropertyMode
import org.gradle.declarative.dsl.schema.DataTopLevelFunction
import org.gradle.declarative.dsl.schema.DataType
import org.gradle.declarative.dsl.schema.DataType.ParameterizedTypeInstance.TypeArgument
import org.gradle.declarative.dsl.schema.DataTypeRef
import org.gradle.declarative.dsl.schema.EnumClass
import org.gradle.declarative.dsl.schema.ExternalObjectProviderKey
import org.gradle.declarative.dsl.schema.FqName
import org.gradle.declarative.dsl.schema.FunctionSemantics
import org.gradle.declarative.dsl.schema.FunctionSemantics.AccessAndConfigure
import org.gradle.declarative.dsl.schema.FunctionSemantics.AccessAndConfigure.ReturnType
import org.gradle.declarative.dsl.schema.FunctionSemantics.AddAndConfigure
import org.gradle.declarative.dsl.schema.FunctionSemantics.Builder
import org.gradle.declarative.dsl.schema.FunctionSemantics.ConfigureSemantics.ConfigureBlockRequirement
import org.gradle.declarative.dsl.schema.FunctionSemantics.Pure
import org.gradle.declarative.dsl.schema.ParameterSemantics
import org.gradle.declarative.dsl.schema.SchemaItemMetadata
import org.gradle.declarative.dsl.schema.SchemaMemberFunction
import org.gradle.declarative.dsl.schema.VarargParameter
import org.gradle.internal.declarativedsl.language.DataTypeInternal
import java.util.Collections


// TODO: we're adding a bunch of custom equals implementations to data classes to make them work
//  with TAPI dynamic proxies, but we also need to handle data objects in some kind of similar way
//  or rewrite them as data classes... or we need a completely different solution for the root problem

@Serializable
@SerialName("analysisSchema")
data class DefaultAnalysisSchema(
    override val topLevelReceiverType: DataClass,
    override val dataClassTypesByFqName: Map<FqName, DataType.ClassDataType>,
    override val genericSignaturesByFqName: Map<FqName, DataType.ParameterizedTypeSignature>,
    override val genericInstantiationsByFqName: Map<FqName, Map<List<TypeArgument>, DataType.ClassDataType>>,
    override val externalFunctionsByFqName: Map<FqName, DataTopLevelFunction>,
    override val externalObjectsByFqName: Map<FqName, ExternalObjectProviderKey>,
    override val defaultImports: Set<FqName>,
) : AnalysisSchema {
    override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
        if (this === other) return true
        if (other == null || other !is AnalysisSchema) return false
        return other.topLevelReceiverType == topLevelReceiverType &&
            other.dataClassTypesByFqName == dataClassTypesByFqName &&
            other.genericSignaturesByFqName == genericSignaturesByFqName &&
            other.genericInstantiationsByFqName == genericInstantiationsByFqName &&
            other.externalFunctionsByFqName == externalFunctionsByFqName &&
            other.externalObjectsByFqName == externalObjectsByFqName &&
            other.defaultImports == defaultImports
    }

    companion object Empty : AnalysisSchema {
        override val topLevelReceiverType: DataClass = DefaultDataClass
        override val dataClassTypesByFqName: Map<FqName, DataClass> = mapOf()
        override val genericSignaturesByFqName: Map<FqName, DataType.ParameterizedTypeSignature> = emptyMap()
        override val genericInstantiationsByFqName: Map<FqName, Map<List<TypeArgument>, DataType.ClassDataType>> = emptyMap()
        override val externalFunctionsByFqName: Map<FqName, DataTopLevelFunction> = mapOf()
        override val externalObjectsByFqName: Map<FqName, ExternalObjectProviderKey> = mapOf()
        override val defaultImports: Set<FqName> = setOf()

        @Suppress("unused")
        private
        fun readResolve(): Any = Empty
    }
}


@Serializable
@SerialName("data")
data class DefaultDataClass(
    override val name: FqName,
    override val javaTypeName: String,
    override val javaTypeArgumentTypeNames: List<String>,
    override val supertypes: Set<FqName>,
    override val properties: List<DataProperty>,
    override val memberFunctions: List<SchemaMemberFunction>,
    override val constructors: List<DataConstructor>
) : DataClass {
    override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
        if (this === other) return true
        if (other == null || other !is DataClass) return false
        return other.name == name &&
            other.javaTypeName == javaTypeName &&
            other.javaTypeArgumentTypeNames == javaTypeArgumentTypeNames &&
            other.supertypes == supertypes &&
            other.properties == properties &&
            other.memberFunctions == memberFunctions &&
            other.constructors == constructors
    }

    override fun toString(): String = name.simpleName

    companion object Empty : DataClass {
        override val name: FqName = FqName
        override val javaTypeName: String = ""
        override val javaTypeArgumentTypeNames: List<String> = emptyList()
        override val supertypes: Set<FqName> = Collections.emptySet()
        override val properties: List<DataProperty> = Collections.emptyList()
        override val memberFunctions: List<SchemaMemberFunction> = Collections.emptyList()
        override val constructors: List<DataConstructor> = Collections.emptyList()

        @Suppress("unused")
        private
        fun readResolve(): Any = Empty
    }
}


@Serializable
@SerialName("enum")
data class DefaultEnumClass(
    override val name: FqName,
    override val javaTypeName: String,
    override val entryNames: List<String>
) : EnumClass {

    override fun toString(): String = name.simpleName

    override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
        if (this === other) return true
        if (other == null || other !is EnumClass) return false
        return other.name == name &&
            other.javaTypeName == javaTypeName &&
            other.entryNames == entryNames
    }

    companion object Empty : EnumClass {
        override val name: FqName = FqName
        override val javaTypeName: String = ""
        override val entryNames: List<String> = emptyList()

        @Suppress("unused")
        private
        fun readResolve(): Any = Empty
    }
}


@Serializable
@SerialName("dataProperty")
data class DefaultDataProperty(
    override val name: String,
    override val valueType: DataTypeRef,
    override val mode: PropertyMode,
    override val hasDefaultValue: Boolean,
    override val isHiddenInDsl: Boolean = false,
    override val isDirectAccessOnly: Boolean = false
) : DataProperty {
    override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
        if (this === other) return true
        if (other == null || other !is DataProperty) return false
        return other.name == name &&
            other.valueType == valueType &&
            other.mode == mode &&
            other.hasDefaultValue == hasDefaultValue &&
            other.isHiddenInDsl == isHiddenInDsl &&
            other.isDirectAccessOnly == isDirectAccessOnly
    }

    data object DefaultPropertyMode {
        @Serializable
        data object DefaultReadWrite : PropertyMode.ReadWrite {
            @Suppress("unused")
            private
            fun readResolve(): Any = DefaultReadWrite
        }


        @Serializable
        data object DefaultReadOnly : PropertyMode.ReadOnly {
            @Suppress("unused")
            private
            fun readResolve(): Any = DefaultReadOnly
        }


        @Serializable
        data object DefaultWriteOnly : PropertyMode.WriteOnly {
            @Suppress("unused")
            private
            fun readResolve(): Any = DefaultWriteOnly
        }
    }
}


val DataProperty.isReadOnly: Boolean
    get() = mode is PropertyMode.ReadOnly


val DataProperty.isWriteOnly: Boolean
    get() = mode is PropertyMode.WriteOnly


@Serializable
@SerialName("dataBuilderFunction")
data class DefaultDataBuilderFunction(
    override val receiver: DataTypeRef,
    override val simpleName: String,
    override val isDirectAccessOnly: Boolean,
    override val dataParameter: DataParameter,
    override val metadata: List<SchemaItemMetadata> = emptyList(),
) : DataBuilderFunction {
    override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
        if (this === other) return true
        if (other == null || other !is DataBuilderFunction) return false
        return other.receiver == receiver &&
            other.simpleName == simpleName &&
            other.isDirectAccessOnly == isDirectAccessOnly &&
            other.dataParameter == dataParameter &&
            other.metadata == metadata
    }

    override val semantics: Builder = FunctionSemanticsInternal.DefaultBuilder(receiver)
    override val parameters: List<DataParameter>
        get() = listOf(dataParameter)
}


@Serializable
@SerialName("dataTopLevelFunction")
data class DefaultDataTopLevelFunction(
    override val packageName: String,
    override val ownerJvmTypeName: String,
    override val simpleName: String,
    override val parameters: List<DataParameter>,
    override val semantics: Pure,
) : DataTopLevelFunction {
    override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
        if (this === other) return true
        if (other == null || other !is DataTopLevelFunction) return false
        return other.packageName == packageName &&
            other.ownerJvmTypeName == ownerJvmTypeName &&
            other.simpleName == simpleName &&
            other.parameters == parameters &&
            other.semantics == semantics
    }
}


@Serializable
@SerialName("dataMemberFunction")
data class DefaultDataMemberFunction(
    override val receiver: DataTypeRef,
    override val simpleName: String,
    override val parameters: List<DataParameter>,
    override val isDirectAccessOnly: Boolean,
    override val semantics: FunctionSemantics,
    override val metadata: List<SchemaItemMetadata> = emptyList()
) : DataMemberFunction {
    override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
        if (this === other) return true
        if (other == null || other !is DataMemberFunction) return false
        return other.receiver == receiver &&
            other.simpleName == simpleName &&
            other.parameters == parameters &&
            other.isDirectAccessOnly == isDirectAccessOnly &&
            other.semantics == semantics &&
            other.metadata == metadata
    }
}


@Serializable
@SerialName("dataConstructor")
data class DefaultDataConstructor(
    override val parameters: List<DataParameter>,
    override val dataClass: DataTypeRef
) : DataConstructor {
    override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
        if (this === other) return true
        if (other == null || other !is DataConstructor) return false
        return other.parameters == parameters &&
            other.dataClass == dataClass
    }
    override val simpleName
        get() = "<init>"
    override val semantics: Pure = FunctionSemanticsInternal.DefaultPure(dataClass)
}


@Serializable
data class DefaultDataParameter(
    override val name: String?,
    @SerialName("privateType")
    override val type: DataTypeRef,
    override val isDefault: Boolean,
    override val semantics: ParameterSemantics
) : DataParameter {
    override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
        if (this === other) return true
        if (other == null || other !is DataParameter) return false
        return other.name == name &&
            other.type == type &&
            other.isDefault == isDefault &&
            other.semantics == semantics
    }
}

@Serializable
data class DefaultVarargParameter(
    override val name: String?,
    @SerialName("privateType")
    override val type: DataTypeRef,
    override val isDefault: Boolean,
    override val semantics: ParameterSemantics
) : VarargParameter {
    override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
        if (this === other) return true
        if (other == null || other !is VarargParameter) return false
        return other.name == name &&
            other.type == type &&
            other.isDefault == isDefault &&
            other.semantics == semantics
    }
}


object ParameterSemanticsInternal {
    @Serializable
    @SerialName("storeValueInProperty")
    data class DefaultStoreValueInProperty(override val dataProperty: DataProperty) : ParameterSemantics.StoreValueInProperty {
        override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
            if (this === other) return true
            if (other == null || other !is ParameterSemantics.StoreValueInProperty) return false
            return other.dataProperty == dataProperty
        }
    }

    @Serializable
    @SerialName("identityKey")
    data class DefaultIdentityKey(override val basedOnProperty: DataProperty?) : ParameterSemantics.IdentityKey {
        override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
            if (this === other) return true
            if (other == null || other !is ParameterSemantics.IdentityKey) return false
            return other.basedOnProperty == basedOnProperty
        }
    }

    @Serializable
    @SerialName("unknown")
    data object DefaultUnknown : ParameterSemantics.Unknown {
        @Suppress("unused")
        private
        fun readResolve(): Any = DefaultUnknown
    }
}


object FunctionSemanticsInternal {

    @Serializable
    @SerialName("builder")
    data class DefaultBuilder(private val objectType: DataTypeRef) : Builder {
        override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
            if (this === other) return true
            if (other == null || other !is Builder) return false
            return other.returnValueType == returnValueType
        }

        override val returnValueType: DataTypeRef
            get() = objectType
    }

    @Serializable
    @SerialName("accessAndConfigure")
    data class DefaultAccessAndConfigure(
        override val accessor: ConfigureAccessor,
        override val returnType: ReturnType,
        override val configureBlockRequirement: ConfigureBlockRequirement
    ) : AccessAndConfigure {
        override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
            if (this === other) return true
            if (other == null || other !is AccessAndConfigure) return false
            return other.accessor == accessor &&
                other.returnType == returnType &&
                other.configureBlockRequirement == configureBlockRequirement
        }
        override val returnValueType: DataTypeRef
            get() = when (returnType) {
                is ReturnType.ConfiguredObject -> accessor.objectType
                is ReturnType.Unit -> DataTypeInternal.DefaultUnitType.ref
            }

        /** Implementations for [ReturnType] */
        object DefaultReturnType {
            @Serializable
            @SerialName("configuredObject")
            data object DefaultConfiguredObject : ReturnType.ConfiguredObject {
                @Suppress("unused")
                private
                fun readResolve(): Any = DefaultConfiguredObject
            }

            @Serializable
            @SerialName("unit")
            object DefaultUnit : ReturnType.Unit {
                @Suppress("unused")
                private
                fun readResolve(): Any = DefaultUnit
            }
        }
    }

    @Serializable
    @SerialName("addAndConfigure")
    data class DefaultAddAndConfigure(
        private val objectType: DataTypeRef,
        override val configureBlockRequirement: ConfigureBlockRequirement
    ) : AddAndConfigure {
        override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
            if (this === other) return true
            if (other == null || other !is AddAndConfigure) return false
            return other.returnValueType == returnValueType &&
                other.configureBlockRequirement == configureBlockRequirement
        }

        override val returnValueType: DataTypeRef
            get() = objectType

        override val configuredType: DataTypeRef
            get() = returnValueType
    }

    @Serializable
    @SerialName("pure")
    data class DefaultPure(override val returnValueType: DataTypeRef) : Pure {
        override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
            if (this === other) return true
            if (other == null || other !is Pure) return false
            return other.returnValueType == returnValueType
        }
    }

    /** Implementations for [ConfigureBlockRequirement] */
    data object DefaultConfigureBlockRequirement {
        @Serializable
        @SerialName("notAllowed")
        data object DefaultNotAllowed : ConfigureBlockRequirement.NotAllowed {
            @Suppress("unused")
            private
            fun readResolve(): Any = DefaultNotAllowed
        }

        @Serializable
        @SerialName("optional")
        data object DefaultOptional : ConfigureBlockRequirement.Optional {
            @Suppress("unused")
            private
            fun readResolve(): Any = DefaultOptional
        }

        @Serializable
        @SerialName("required")
        data object DefaultRequired : ConfigureBlockRequirement.Required {
            @Suppress("unused")
            private
            fun readResolve(): Any = DefaultRequired
        }
    }
}


object ConfigureAccessorInternal {
    @Serializable
    @SerialName("property")
    data class DefaultProperty(override val dataProperty: DataProperty) : ConfigureAccessor.Property {
        override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
            if (this === other) return true
            if (other == null || other !is ConfigureAccessor.Property) return false
            return other.dataProperty == dataProperty
        }
    }

    @Serializable
    @SerialName("custom")
    data class DefaultCustom(override val objectType: DataTypeRef, override val customAccessorIdentifier: String) : ConfigureAccessor.Custom {
        override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
            if (this === other) return true
            if (other == null || other !is ConfigureAccessor.Custom) return false
            return other.objectType == objectType && other.customAccessorIdentifier == customAccessorIdentifier
        }
    }

    @Serializable
    @SerialName("configuringLambdaArgument")
    data class DefaultConfiguringLambdaArgument(override val objectType: DataTypeRef) : ConfigureAccessor.ConfiguringLambdaArgument {
        override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
            if (this === other) return true
            if (other == null || other !is ConfigureAccessor.ConfiguringLambdaArgument) return false
            return other.objectType == objectType
        }
    }

    // TODO: configure all elements by addition key?
    // TODO: Do we want to support configuring external objects?
}


@Serializable
data class DefaultFqName(override val packageName: String, override val simpleName: String) : FqName {
    companion object {
        fun parse(fqNameString: String): FqName {
            val parts = fqNameString.split(".")
            return DefaultFqName(parts.dropLast(1).joinToString("."), parts.last())
        }
    }

    override
    val qualifiedName by lazy { "$packageName.$simpleName" }

    override fun toString(): String = qualifiedName

    override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
        if (this === other) return true
        if (other == null || other !is FqName) return false
        return other.packageName == packageName && other.simpleName == simpleName
    }
}


val DataTopLevelFunction.fqName: FqName
    get() = DefaultFqName(packageName, simpleName)


@Serializable
@SerialName("externalObjectProviderKey")
data class DefaultExternalObjectProviderKey(override val objectType: DataTypeRef) : ExternalObjectProviderKey {
    override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
        if (this === other) return true
        if (other == null || other !is ExternalObjectProviderKey) return false
        return other.objectType == objectType
    }
}


object DataTypeRefInternal {
    @Serializable
    @SerialName("dataTypeRefType")
    data class DefaultType(override val dataType: DataType.PrimitiveType) : DataTypeRef.Type {
        override fun toString(): String = dataType.toString()

        override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
            if (this === other) return true
            if (other == null || other !is DataTypeRef.Type) return false
            return other.dataType == dataType
        }
    }

    @Serializable
    @SerialName("dataTypeRefName")
    data class DefaultName(override val fqName: FqName) : DataTypeRef.Name {
        override fun toString(): String = fqName.simpleName

        override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
            if (this === other) return true
            if (other == null || other !is DataTypeRef.Name) return false
            return other.fqName == fqName
        }
    }

    @Serializable
    @SerialName("dataTypeRefNameWithArgs")
    data class DefaultNameWithArgs(override val fqName: FqName, override val typeArguments: List<TypeArgument>) : DataTypeRef.NameWithArgs {
        override fun toString(): String = fqName.simpleName + "<${typeArguments.joinToString { (it as? TypeArgument.ConcreteTypeArgument)?.type?.toString() ?: "*" }}>"

        override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
            if (this === other) return true
            if (other == null || other !is DataTypeRef.NameWithArgs) return false
            return other.fqName == fqName
        }
    }
}

object TypeArgumentInternal {
    @Serializable
    @SerialName("concreteType")
    data class DefaultConcreteTypeArgument(@SerialName("dataType") override val type: DataTypeRef) : TypeArgument.ConcreteTypeArgument {
        override fun toString(): String = type.toString()

        override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
            if (this === other) return true
            if (other == null || other !is TypeArgument.ConcreteTypeArgument) return false
            return other.type == type
        }
    }

    @Serializable
    @SerialName("starProjection")
    class DefaultStarProjection : TypeArgument.StarProjection {
        override fun toString(): String = "*"

        override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
            if (this === other) return true
            if (other == null || other !is TypeArgument.StarProjection) return false
            return true
        }

        override fun hashCode(): Int { // needed due to Detekt not handling @Suppress("EqualsOrHashCode") well in this case
            return super.hashCode()
        }
    }
}


object SchemaItemMetadataInternal {
    object SchemaMemberOriginInternal {
        @Serializable
        @SerialName("containerElementFactory")
        data class DefaultContainerElementFactory(override val elementType: DataTypeRef) : ContainerElementFactory {
            override fun equals(other: Any?): Boolean { // needed to also work with Java dynamic proxies generated by the Tooling API
                if (this === other) return true
                if (other == null || other !is ContainerElementFactory) return false
                return other.elementType == elementType
            }
        }
    }
}


inline fun <reified T : SchemaItemMetadata> List<SchemaItemMetadata>.dataOfTypeOrNull(): T? = singleOrNull { it is T } as? T

val DataType.ref: DataTypeRef
    get() = when (this) {
        is DataType.PrimitiveType -> DataTypeRefInternal.DefaultType(this)
        is DataType.ParameterizedTypeInstance -> DataTypeRefInternal.DefaultNameWithArgs(name, typeArguments)
        is DataType.ClassDataType -> DataTypeRefInternal.DefaultName(name)
    }
